#include <Power.h>#include <Globals.h>#include <Folders.h>#define CTS_BIT 0#define DCD_BIT 1#define PREF_FILE "\pPB AirTalk Preferences"#define PREF_TYPE 'PREF'#define PREF_CREATOR 'PBAT'#define PREF_MAGIC 'PBAT'#define PREF_VERSION 10void SCCInit(struct cdevData* store);void DTROn(struct cdevData* store);void DTROff(struct cdevData* store);short ReadSCCBit(struct cdevData* store, int which);short OpenOrCreatePrefs(struct cdevData* store);void ComitPrefs(struct cdevData* store);void updateControls(struct cdevData* incomingData, DialogPtr dlogp, short numitems);void setupCheckbox(struct cdevData* store, DialogPtr dlogp, short numitems);short getCheckboxValue(struct cdevData* store, DialogPtr dlogp, short numitems);void FileErrorAlert(short error, Str255 where);#define FLAGS_ACTIVE 0x00struct cdevPrefs {	unsigned long magic;	unsigned short version;	unsigned short flags;};struct cdevData {	char* sccRBase;	char* sccWBase;	short statusVal;	short activityVal;	Boolean resetStatus;	struct cdevPrefs prefs;	short fileno;};#define	ENABLECHK 1#define RESETBTN 2#define STATUSCTL 4#define ACTIVITYCTL 5#define PWRONBTN 8#define PWROFFBTN 9pascal long pbatcdev(short msg, short item, short numitems, short cpid, EventRecord *evt,						long cdevValue, DialogPtr dlogp){	struct cdevData *newData;	struct cdevData *incomingData = (struct cdevData*)cdevValue;	long res;	short val;	OSErr ret;	Byte modemStatus;	switch(msg) {		case macDev: return 1; break;		case initDev:			newData = (struct cdevData*)NewPtr(sizeof(struct cdevData));			if (newData == 0L)				return 0L;						// Make sure that the AirTalk card is inserted			ret = ModemStatus(&modemStatus);						// bit 3 is "modem inserted"			if (modemStatus & (1<<0x03)) {							// Should we contnue anyways?				ret = CautionAlert(-4034, nil);								// no. adios.				if (ret != 1)					return 0L;			}						// Make sure power is on			AOn();						SCCInit(newData);			newData->resetStatus = false;			newData->statusVal = 0;			newData->activityVal = 0;						res = OpenOrCreatePrefs(newData);						if (res == -1) {				DisposPtr((Ptr)newData);				return 0;			}						newData->fileno = res;						setupCheckbox(newData, dlogp, numitems);						return (long)newData; 		break;				case closeDev:						val = getCheckboxValue(newData, dlogp, numitems);						incomingData->prefs.flags = 0;			if (val)				incomingData->prefs.flags |= (1<<FLAGS_ACTIVE);						ComitPrefs(incomingData);			DisposPtr((Ptr)cdevValue);		break;				case hitDev:			if (item - numitems == RESETBTN) {				if (incomingData->resetStatus)					DTROff(incomingData);				else					DTROn(incomingData);								incomingData->resetStatus = ~incomingData->resetStatus;			} else if (item - numitems == PWRONBTN) {				AOn();			} else if (item - numitems == PWROFFBTN) {				AOff();			} else if (item - numitems == ENABLECHK) {				Handle checkbox;				short type;				Rect box;				short val;					GetDItem(dlogp, numitems + ENABLECHK, &type, &checkbox, &box);				SetCtlValue((ControlHandle)checkbox, 					GetCtlValue((ControlHandle)checkbox) ^ 1);			}		break;				case nulDev:			updateControls(incomingData, dlogp, numitems);		break;	}		return cdevValue;}void setupCheckbox(struct cdevData* store, DialogPtr dlogp, short numitems) {	Handle checkbox;	short type;	Rect box;	short val;		GetDItem(dlogp, numitems + ENABLECHK, &type, &checkbox, &box);	SetCtlValue((ControlHandle)checkbox, (store->prefs.flags & (1<<FLAGS_ACTIVE)) != 0);}short getCheckboxValue(struct cdevData* store, DialogPtr dlogp, short numitems) {	Handle checkbox;	short type;	Rect box;	short val;		GetDItem(dlogp, numitems + ENABLECHK, &type, &checkbox, &box);	val = GetCtlValue((ControlHandle)checkbox);		return (val != 0);}void updateControls(struct cdevData* incomingData, DialogPtr dlogp, short numitems) {	Handle statusCtl, activityCtl;	short type;	Rect box;	short val;		GetDItem(dlogp, numitems + STATUSCTL, &type, &statusCtl, &box);	GetDItem(dlogp, numitems + ACTIVITYCTL, &type, &activityCtl, &box);		val = ReadSCCBit(incomingData, CTS_BIT);	if (val != incomingData->statusVal) {		SetCtlValue((ControlHandle)statusCtl, val);		incomingData->statusVal = val;	}		val = ReadSCCBit(incomingData, DCD_BIT);	if (val != incomingData->activityVal) {		SetCtlValue((ControlHandle)activityCtl, val);		incomingData->activityVal = val;	}}short OpenOrCreatePrefs(struct cdevData* store) {	OSErr res;	short fnr = -1;	long prefDir;	short prefVol;	Boolean created = false;	long count;	Str255 errStr;		// We should run only on system 7 so assume it is here	res = FindFolder(kOnSystemDisk, kPreferencesFolderType,			   kCreateFolder, &prefVol, &prefDir);			   	if (res != noErr) {		FileErrorAlert(res, "\pFindFolder");		return -1;	}			res = HOpen(prefVol, prefDir, PREF_FILE, fsRdWrPerm, &fnr);	if (res == fnfErr) {		HCreate(prefVol, prefDir, PREF_FILE, PREF_CREATOR, PREF_TYPE);		res = HOpen(prefVol, prefDir, PREF_FILE, fsRdWrPerm, &fnr);		created = true;	}		if (res == opWrErr) {		FSClose(fnr);		fnr = -1;		res = HOpen(prefVol, prefDir, PREF_FILE, fsRdWrPerm, &fnr);	}		if (res != noErr) {		FileErrorAlert(res, "\pHOpen");		return -1;	}			SetFPos(fnr, fsFromStart, 0L);		count = sizeof(struct cdevPrefs);	res = FSRead(fnr, &count, &store->prefs);		if (res != noErr && res != eofErr) {		FileErrorAlert(res, "\pFSRead");		return -1;	}		// Make new preferences		if (count < sizeof(struct cdevPrefs) || store->prefs.magic != PREF_MAGIC) {		store->prefs.magic = PREF_MAGIC;		store->prefs.version = PREF_VERSION;		store->prefs.flags = 0;	}		return fnr;}void ComitPrefs(struct cdevData* store) {	long count;	OSErr res;		SetFPos(store->fileno, fsFromStart, 0L);		count = sizeof(struct cdevPrefs);	res = FSWrite(store->fileno, &count, &(store->prefs));	FSClose(store->fileno);	}void FileErrorAlert(short error, Str255 where) {	Str255 errStr;		NumToString(error, errStr);	ParamText(errStr, where, "\p", "\p");	NoteAlert(-4033, nil);}main() {} // c'mon!!/****** SCC STUFF *******/#define aData	6#define aCtl	2#define bData	4#define bCtl	0#define SCC_CTS_BIT	0x05#define SCC_DCD_BIT 0x03void SCCInit(struct cdevData* store) {	store->sccRBase = (char *)SCCRd;	store->sccWBase = (char *)SCCWr;}void DTROn(struct cdevData* store) {	store->sccWBase[aCtl] = 5;	store->sccWBase[aCtl] |= 0x80;}void DTROff(struct cdevData* store) {	store->sccWBase[aCtl] = 5;	store->sccWBase[aCtl] &= ~(0x80);}short ReadSCCBit(struct cdevData* store, int which) {	unsigned char val;	store->sccWBase[aCtl] = 0;	val = store->sccRBase[aCtl];		if (which == 0)		return (val & (1<<SCC_CTS_BIT));	else		return (val & (1<<SCC_DCD_BIT));}