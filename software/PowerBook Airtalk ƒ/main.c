#include <Power.h>#include <Globals.h>#include <Folders.h>#include <GestaltEqu.h>//#define DEBUG#define CTS_BIT 0#define DCD_BIT 1#define PREF_FILE "\pPB AirTalk Preferences"#define PREF_TYPE 'PREF'#define PREF_CREATOR 'PBAT'#define PREF_MAGIC 'PBAT'#define PREF_VERSION 10void SCCInit(struct cdevData* store);void DTROn(struct cdevData* store);void DTROff(struct cdevData* store);short ReadSCCBit(struct cdevData* store, int which);Byte ReadSCCByteCtl(struct cdevData* store);short OpenOrCreatePrefs(struct cdevData* store);void ComitPrefs(struct cdevData* store);void doNullEvent(struct cdevData* incomingData, DialogPtr dlogp, short numitems);void setupCheckbox(struct cdevData* store, DialogPtr dlogp, short numitems);short getCheckboxValue(struct cdevData* store, DialogPtr dlogp, short numitems);void doUpdateEvent(struct cdevData* incomingData, DialogPtr dlogp, short numitems);void uglyDebugChar(Byte c, int v);void printDebugInfo(struct cdevData* store);void FileErrorAlert(short error, Str255 where);#define FLAGS_ACTIVE 0x00struct cdevPrefs {	unsigned long magic;	unsigned short version;	unsigned short flags;};struct cdevData {	char* sccRBase;	char* sccWBase;	short statusVal;	short activityVal;	Boolean resetStatus;	struct cdevPrefs prefs;	short fileno;};#define	ENABLECHK 1#define RESETBTN 2#define PWRONBTN 6#define PWROFFBTN 7#define ICON_ACT_ON 8#define ICON_ACT_OFF 9#define ICON_CON_ON 11#define ICON_CON_OFF 12#define VERSION_ITEM 14#define STRINGS -4033enum {	STR_VERSION = 1} strEnum;/****** SCC STUFF *******/#define aData	6#define aCtl	2#define bData	4#define bCtl	0#define SCC_CTS_BIT	0x05#define SCC_DCD_BIT 0x03/****** END SCC *********/pascal long pbatcdev(short msg, short item, short numitems, short cpid, EventRecord *evt,						long cdevValue, DialogPtr dlogp){	struct cdevData *newData;	struct cdevData *incomingData = (struct cdevData*)cdevValue;	long res;	short val;	OSErr ret;	Byte modemStatus;	long powerManagerGestalt;	switch(msg) {		case macDev:			// Make sure PowerManager is present,			// or the cdev will fail when we call			// ModemStatus			Gestalt(gestaltPowerMgrAttr, &powerManagerGestalt);			if ((powerManagerGestalt & (1 << gestaltPMgrExists)) == 0)				return 0L;				return 1; 		break;		case initDev:			SetDAFont(systemFont);			newData = (struct cdevData*)NewPtr(sizeof(struct cdevData));			if (newData == 0L)				return 0L;						// Make sure that the AirTalk card is inserted			ret = ModemStatus(&modemStatus);						// bit 3 is "modem inserted" (1<<0x03)			if (!(modemStatus & 0x08)) {							// Should we contnue anyways?				ret = CautionAlert(-4034, nil);								// no. adios.				if (ret != 1)					return 0L;			}						// Make sure power is on			AOn();						SCCInit(newData);			newData->resetStatus = false;			newData->statusVal = 0xFF;			newData->activityVal = 0;						res = OpenOrCreatePrefs(newData);						if (res == -1) {				DisposPtr((Ptr)newData);				return 0;			}						newData->fileno = res;						HideDItem(dlogp, ICON_ACT_ON);			HideDItem(dlogp, ICON_CON_ON);						setupCheckbox(newData, dlogp, numitems);						return (long)newData; 		break;				case closeDev:						val = getCheckboxValue(newData, dlogp, numitems);						incomingData->prefs.flags = 0;			if (val)				incomingData->prefs.flags |= (1<<FLAGS_ACTIVE);						ComitPrefs(incomingData);			DisposPtr((Ptr)cdevValue);		break;				case hitDev:			if (item - numitems == RESETBTN) {				if (incomingData->resetStatus)					DTROff(incomingData);				else					DTROn(incomingData);								incomingData->resetStatus = ~incomingData->resetStatus;			} else if (item - numitems == PWRONBTN) {				AOn();			} else if (item - numitems == PWROFFBTN) {				AOff();			} else if (item - numitems == ENABLECHK) {				Handle checkbox;				short type;				Rect box;				short val;					GetDItem(dlogp, numitems + ENABLECHK, &type, &checkbox, &box);				SetCtlValue((ControlHandle)checkbox, 					GetCtlValue((ControlHandle)checkbox) ^ 1);			}		break;				case updateDev:			doUpdateEvent(incomingData, dlogp, numitems);		break;				case nulDev:			doNullEvent(incomingData, dlogp, numitems);#ifdef DEBUG			printDebugInfo(incomingData);#endif		break;	}		return cdevValue;}void setupCheckbox(struct cdevData* store, DialogPtr dlogp, short numitems) {	Handle checkbox;	short type;	Rect box;	short val;		GetDItem(dlogp, numitems + ENABLECHK, &type, &checkbox, &box);	SetCtlValue((ControlHandle)checkbox, (store->prefs.flags & (1<<FLAGS_ACTIVE)) != 0);}short getCheckboxValue(struct cdevData* store, DialogPtr dlogp, short numitems) {	Handle checkbox;	short type;	Rect box;	short val;		GetDItem(dlogp, numitems + ENABLECHK, &type, &checkbox, &box);	val = GetCtlValue((ControlHandle)checkbox);		return (val != 0);}void doUpdateEvent(struct cdevData* incomingData, DialogPtr dlogp, short numitems) {	Handle item;	short type;	Rect box;	short val;	Str255 str;		GetDItem(dlogp, numitems + VERSION_ITEM, &type, &item, &box);		GetIndString(str, STRINGS, STR_VERSION);		MoveTo(box.left,box.bottom);	DrawString(str);}void doNullEvent(struct cdevData* incomingData, DialogPtr dlogp, short numitems) {	short val;	Byte scc_reg;		scc_reg = ReadSCCByteCtl(incomingData);		//val = ReadSCCBit(incomingData, DCD_BIT);	val = !(scc_reg & (1<<SCC_DCD_BIT)); // DCD is negated	if (val != incomingData->statusVal) {		incomingData->statusVal = val;				if (incomingData->statusVal) {			HideDItem(dlogp, ICON_CON_OFF);			ShowDItem(dlogp, ICON_CON_ON);		} else {			HideDItem(dlogp, ICON_CON_ON);			ShowDItem(dlogp, ICON_CON_OFF);		}	}		//val = ReadSCCBit(incomingData, CTS_BIT);	val = !!(scc_reg & (1<<SCC_CTS_BIT));	if (val != incomingData->activityVal) {		incomingData->activityVal = val;				if (incomingData->activityVal) {			HideDItem(dlogp, ICON_ACT_OFF);			ShowDItem(dlogp, ICON_ACT_ON);		} else {			HideDItem(dlogp, ICON_ACT_ON);			ShowDItem(dlogp, ICON_ACT_OFF);		}	}}void printDebugInfo(struct cdevData* store) {	Byte modemStatus;	ModemStatus(&modemStatus);	uglyDebugChar(modemStatus, 100);		modemStatus =  ReadSCCByteCtl(store);	uglyDebugChar(modemStatus, 175);}void uglyDebugChar(Byte c, int v) {	int i;	int pos = 100;	Rect theRect;	Pattern myPat;		StuffHex(&myPat, "\p0000000000000000");		SetRect(&theRect, pos, v-8, pos + 100, v+2);	FillRect(&theRect, &myPat);	MoveTo(pos, v);		for (i = 7; i >= 0; i--) {		MoveTo(pos, v);		pos += 10;				if (c & (1<<i))			DrawString("\p1");		else			DrawString("\p0");	}}short OpenOrCreatePrefs(struct cdevData* store) {	OSErr res;	short fnr = -1;	long prefDir;	short prefVol;	Boolean created = false;	long count;	Str255 errStr;		// We should run only on system 7 so assume it is here	res = FindFolder(kOnSystemDisk, kPreferencesFolderType,			   kCreateFolder, &prefVol, &prefDir);			   	if (res != noErr) {		FileErrorAlert(res, "\pFindFolder");		return -1;	}			res = HOpen(prefVol, prefDir, PREF_FILE, fsRdWrPerm, &fnr);	if (res == fnfErr) {		HCreate(prefVol, prefDir, PREF_FILE, PREF_CREATOR, PREF_TYPE);		res = HOpen(prefVol, prefDir, PREF_FILE, fsRdWrPerm, &fnr);		created = true;	}		if (res == opWrErr) {		FSClose(fnr);		fnr = -1;		res = HOpen(prefVol, prefDir, PREF_FILE, fsRdWrPerm, &fnr);	}		if (res != noErr) {		FileErrorAlert(res, "\pHOpen");		return -1;	}			SetFPos(fnr, fsFromStart, 0L);		count = sizeof(struct cdevPrefs);	res = FSRead(fnr, &count, &store->prefs);		if (res != noErr && res != eofErr) {		FileErrorAlert(res, "\pFSRead");		return -1;	}		// Make new preferences		if (count < sizeof(struct cdevPrefs) || store->prefs.magic != PREF_MAGIC) {		store->prefs.magic = PREF_MAGIC;		store->prefs.version = PREF_VERSION;		store->prefs.flags = 0;	}		return fnr;}void ComitPrefs(struct cdevData* store) {	long count;	OSErr res;		SetFPos(store->fileno, fsFromStart, 0L);		count = sizeof(struct cdevPrefs);	res = FSWrite(store->fileno, &count, &(store->prefs));	FSClose(store->fileno);	}void FileErrorAlert(short error, Str255 where) {	Str255 errStr;		NumToString(error, errStr);	ParamText(errStr, where, "\p", "\p");	NoteAlert(-4033, nil);}main() {} // c'mon!!/****** SCC STUFF *******/void SCCInit(struct cdevData* store) {	store->sccRBase = (char *)SCCRd;	store->sccWBase = (char *)SCCWr;}void DTROn(struct cdevData* store) {	store->sccWBase[aCtl] = 5;	store->sccWBase[aCtl] |= 0x80;}void DTROff(struct cdevData* store) {	store->sccWBase[aCtl] = 5;	store->sccWBase[aCtl] &= ~(0x80);}short ReadSCCBit(struct cdevData* store, int which) {	unsigned char val;	store->sccWBase[aCtl] = 0;	val = store->sccRBase[aCtl];		if (which == CTS_BIT)		return (val & (1<<SCC_CTS_BIT));	else		return (val & (1<<SCC_DCD_BIT));}Byte ReadSCCByteCtl(struct cdevData* store) {	store->sccWBase[aCtl] = 0;	return store->sccRBase[aCtl];}